# アセンブリ入門
## 前提

本学習を行うにあたっての前提を定義する。
- CPUはIntel それに伴い、x86-64を前提とする。
- gccのバージョンは　x86-64 gcc8.1

## アセンブリとは
- アセンブリとは低級言語(低水準言語)
- 機械語とアセンブリは1対1になる

### 汎用レジスタ

|汎用レジスタ||
|:---:|:---:|
|AX|アキュムレータレジスタ|
|BX|ベースレジスタ|
|CX|カウントレジスタ|
|DX|データレジスタ|

プログラマが自由に使える変数
慣習的にBXにはメモリのアドレスを格納するのに使われる。
CXにはループなどプログラムカウンタとして使われることが多い。
AXには計算結果を格納することが多く、足りなければDXを使うといった形だ。

|インデックスレジスタ||
|:---:|:---:|
|SI|ソースレジスタ|
|DI|ディスティネーションインデックス|

|特殊レジスタ||
|:---:|:---:|
|BP|ベースポインタ|
|SP|スタックポインタ|
|IP|インストラクションポインタ|

|セグメントレジスタ||
|:---:|:---:|
|CS|コードセレクタ|
|DS|データセグメント|
|ES|エクストラセグメント|
|SS|スタックセグメント|

レジスタの基本構造

### アキュムレータレジスタ　RAX
演算結果を格納する。</br>
64bit * 64bitの乗算の結果の下位64bitが格納される。</br>
128bit/64bitの整数除算の場合に被除数の下位64bitが格納される。</br>
Linuxのシステムコール番号の指定に使用</br>
システムコールの結果が格納される。</br>
RAXだとバイト幅が64bit(8byte)、EAXはバイト幅が32bit(4byte)</br>
AXのバイト幅は16bit(2byte)、AH、ALのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RAX|||||
|||||EAX||||
|||||||AX||
|||||||AH|AL|

### ベースレジスタ　RBX
汎用レジスタ</br>
RAXと同様のバイト幅が設定されている。</br>
RBXだとバイト幅が64bit(8byte)、EBXはバイト幅が32bit(4byte)</br>
BXのバイト幅は16bit(2byte)、BH、BLのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RBX|||||
|||||EBX||||
|||||||BX||
|||||||BH|BL|

### カウンタレジスタ　RCX
繰り返し回数の設定に使う。</br>
RCXだとバイト幅が64bit(8byte)、ECXはバイト幅が32bit(4byte)</br>
CXのバイト幅は16bit(2byte)、CH、CLのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RCX|||||
|||||ECX||||
|||||||CX||
|||||||CH|CL|

### データレジスタ　RDX
64bit * 64bitの乗算の結果の上位64bitが格納される</br>
128bit / 64bitの整数除算の被除数の上位64bitが格納される。</br>
Linuxのシステムコールの第3引数の設定に使用する。</br>
RDXだとバイト幅が64bit(8byte)、EDXはバイト幅が32bit(4byte)</br>
DXのバイト幅は16bit(2byte)、DH、DLのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RDX|||||
|||||EDX||||
|||||||DX||
|||||||DH|DL|

### ソースインデックスレジスタ　RSI
ストリング型の命令でコピー元(ソース)を示す場合に使用される。</br>
Linuxのシステムコールの第2引数の設定に使用</br>
RSIだとバイト幅が64bit(8byte)、ESIはバイト幅が32bit(4byte)</br>
SIのバイト幅は16bit(2byte)、SILのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RSI|||||
|||||ESI||||
|||||||SI||
||||||||SIL|

### デスティネーションインデックスレジスタ　RDI
ストリング型の命令でコピー先(デスティネーション)を示す場合に使用される。</br>
Linuxのシステムコールの第1引数の設定に使用</br>
RDIだとバイト幅が64bit(8byte)、EDIはバイト幅が32bit(4byte)</br>
DIのバイト幅は16bit(2byte)、DILのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RDI|||||
|||||EDI||||
|||||||DI||
||||||||DIL|

### ベースポインタ　RBP
スタック内のアクセスに使われる。</br>
普通のレジスタとしても利用可能</br>
RBPだとバイト幅が64bit(8byte)、EBPはバイト幅が32bit(4byte)</br>
BPのバイト幅は16bit(2byte)、BPLのバイトはば　は8bit(1byte)となる。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RBP|||||
|||||EBP||||
|||||||BP||
||||||||BPL|

### スタックポインタ　RSP
サブルーチンコールの戻りアドレスを格納する</br>
PUSH, POP命令でレジスタを一時退避、復帰する際に使用する。</br>
RSPだとバイト幅が64bit(8byte)、ESPはバイト幅が32bit(4byte)</br>
SPのバイト幅は16bit(2byte)、SPLのバイトはば　は8bit(1byte)となる。</br>
ただし、64bitモードの場合、ESP、SP、SPLのように部分的にアクセスすることはない。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||RSP|||||
|||||ESP||||
|||||||SP||
||||||||SPL|

### 拡張汎用レジスタ　R8-R15
64bitモードで追加された汎用レジスタ</br>
汎用レジスタと同じように使用可能</br>
R8だとバイト幅が64bit(8byte)、R8Dはバイト幅が32bit(4byte)</br>
R8Wのバイト幅は16bit(2byte)、R8Bのバイトはば　は8bit(1byte)となる。</br>
Linuxのシステムコール呼び出しでは第4引数をR10、第5引数をR8、第6引数をR9に設定する。

|7|6|5|4|3|2|1|0|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
||||R8|||||
|||||R8D||||
|||||||R8W||
||||||||R8B|

### フラグレジスタ　RFFLAGS

いくつかありますが、ここではよく使われるレジスタを紹介します。</br>
もちろんこれ以外にもありますが、ここでは取り上げません。</br>
フラグレジスタはそれぞれ1bitです。

- OFフラグ：</br>
　オーバーフローフラグ。符号付き演算でオーバーフローが発生した場合、1が設定される。
- DFフラグ：</br>
　方向フラグ。文字列操作の方向を示す。(インクリメントかデクリメント)
- CF：</br>
　キャリーフラグ。演算で繰り上げ/繰り下げがある場合、1が設定される。
- PF：</br>
　パリティフラグ。最下位バイトの1の数が偶数の場合1、そうでない場合、0が設定される。
- ZF：</br>
　ゼロフラグ。演算結果が0の時、1がされる。</br>
  例えば、SUB命令で引き算が実行され、結果が0の場合1がセットされ、結果が0以外であれば、0がセットされる。
- SF：</br>
　符号フラグ。結果の最上位のビットが1の場合、1に設定される。</br>
  例えば、SUB命令で引き算され、結果が負数の場合、1がセットされ、結果が負数でない場合、0がセットされる。


レジスタの前、または後についている1文字で、扱うレジスタのバイト長を表す。

|レジスタ{前,後}置記号|場所|ビット幅|バイト幅|備考|利用例|
|:--:|:--:|:--:|:--:|:--:|:--:|
|h|後|8|1|high|ah|
|l|後|8|1|low|al|
|x|後|16|2|eXtended|ax|
|e|前|32|4|Extended|eax|
|r|前|64|8||rax|

## ニーモニック
ニーモニックの基本形

```
MOV destination, source
```

第一オペランドをデスティネーションオペランド、第二オペランドをソースオペランドという。

命令を表すニーモニックの最後についている一文字で、扱うデータのバイト長を表す。

|命令の後置記号|ビット幅|バイト幅|備考|利用例|
|:--:|:--:|:--:|:--:|:--:|
|b|8|1|byte|movb|
|w|16|2|word|movw|
|l|32|4|long|movl|
|q|64|8|quad|movq|

利用例：</br>
意味：EAXレジスタにECXレジスタの値を32bit(8byte)分格納する。

```
movl EAX, ECX
```

※ただし、Intel記法の場合、ニーモニック上のような後置記号を使ってバイト幅を表記しない。

Intel記法のバイト幅を表現するために記法は以下の通りです。

|命令の後に記述する記号|ビット幅|バイト幅|利用例|
|:--:|:--:|:--:|:--:|
|BYTE PTR|8|1|MOV BYTE PTR|
|WORD PTR|16|2|MOV WORD PTR|
|DWORD PTR|32|4|MOV DWORD PTR|
|QWORD PTR|64|8|MOV QWORD PTR|

利用例：</br>
意味：EAXレジスタにECXレジスタの値を32bit(8byte)分格納する。

```
MOV DWORD PTR EAX, ECX
```



### 演算命令
|ニーモニック|命令の動作|備考|
|:--:|:--:|:--|
|ADD|整数加算||
|SUB|整数減算||
|INC|1の加算||
|DEC|1の減算||
|NEG|2の補数||
|AND|ビット毎の論理積||
|OR|ビット毎の論理和||
|XOR|ビット毎の排他的論理和||
|NOT|ビットの反転||
|MUL|符号なし整数乗算||
|IMUL|符号付き数の整数乗算||
|DIV|符号なし整数除算||
|IDIV|符号付き数の整数除算||
|CMP|減算による比較|第1オペランドと第2オペランドを減算する。その結果、ZF、OF、SFなどのフラグレジスタを更新する。|
|TEST|ビット毎の論理積による比較|第1オペランドと第2オペランドとの間のAND(論理積)を取る。その結果、SF、ZF、PFなどのフラグレジスタを更新する。|
|JMP|無条件にジャンプ||
|JE|等しい場合ジャンプ|ZF = 1の場合、ジャンプする。|
|JNE|等しくない場合ジャンプ|ZF = 0の場合、ジャンプする。|
|JNZ|ゼロではない場合、ジャンプ|ZF = 0の場合、ジャンプする。|
|JZ|ゼロである場合、ジャンプ|ZF = 1 の場合、ジャンプする。|
|JC|キャリーあり|CF = 1の場合、ジャンプする。|
|JNC|キャリーなし|CF = 0の場合、ジャンプする。|
|JLE|より小さいか等しい場合、ジャンプ|ZF = 0 または SF <> OFの場合、ジャンプする。|
|JG|より大きい場合、ジャンプ|ZF = 0 かつ SF = OF の場合、ジャンプする。|
|JL|より小さい場合、ジャンプ|SF <> OF の場合、ジャンプする。|
|LOOP|ECXを使用するループ||
|CALL|サブルーチンの呼び出し||
|RET|関数のリターン||
|PUSH|スタックにプッシュ||
|POP|スタックから取り出し||
|SAL|左シフト演算||
|SAR|右シフト演算||


### アドレッシング・モード

命令がレジスターやメモリーにアクセスする方法を示します。

|アクセス方法|例|説明|
|:--|:--|:--|
|即値|ADD EAX, 14|32ビットのEAXに14を足す|
|レジスタとレジスタ|ADD R8L, AL|R8Lに8ビットのALを足す|
|間接アドレッシング|MOV R8W, 1234[8*RAX+RCX]|アドレス 8*RAX + RCX + 1234にあるワードをR8Wに格納する|
|RIP相対アドレッシング|MOV AL, [RIP]|RIPは次命令NOPを指す|

## 参考文献

https://www.mztn.org/lxasm64/amd04.html</br>
https://www.isus.jp/others/introduction-to-x64-assembly/</br>
http://softwaretechnique.jp/OS_Development/Tips/IA32_Instructions/CMP.html